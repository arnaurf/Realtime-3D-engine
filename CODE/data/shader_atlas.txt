//example of some shaders compiled
flat basic.vs flat.fs
texture basic.vs texture.fs
depth quad.vs depth.fs
multi basic.vs multi.fs
shadow basic.vs simple2.fs
deferred quad.vs deferred.fs
deferred_ws basic.vs deferred.fs
forward basic.vs forward.fs
occlusion quad.vs ssao.fs
probe basic.vs probe.fs
reflectionprobe basic.vs reflectionprobe.fs
deferred_reflections quad.vs reflection.fs
volumetric quad.vs volumetric.fs
skybox basic.vs skybox.fs
decals basic.vs decals.fs
tonemapper quad.vs tonemapper.fs
bloom quad.vs bloom.fs
bloom2 quad.vs bloom2.fs

\basic.vs

#version 330 core

in vec3 a_vertex;
in vec3 a_normal;
in vec2 a_uv;
in vec4 a_color;

uniform mat4 u_model;
uniform mat4 u_viewprojection;

//this will store the color for the pixel shader
out vec3 v_position;
out vec3 v_world_position;
out vec3 v_normal;
out vec2 v_uv;
out vec4 v_color;

void main()
{	
	//calcule the normal in camera space (the NormalMatrix is like ViewMatrix but without traslation)
	v_normal = (u_model * vec4( a_normal, 0.0) ).xyz;
	
	//calcule the vertex in object space
	v_position = a_vertex;
	v_world_position = (u_model * vec4( v_position, 1.0) ).xyz;
	
	//store the color in the varying var to use it from the pixel shader
	v_color = a_color;

	//store the texture coordinates
	v_uv = a_uv;

	//calcule the position of the vertex using the matrices
	gl_Position = u_viewprojection * vec4( v_world_position, 1.0 );
}

\quad.vs

#version 330 core

in vec3 a_vertex;
in vec2 a_uv;
out vec2 v_uv;

void main()
{	
	v_uv = a_uv;
	gl_Position = vec4( a_vertex, 1.0 );
}

\simple.fs

#version 330 core

in vec4 v_color;
out vec4 FragColor;

void main()
{
	FragColor = vec4(v_color.xyz, 1.0);
	//FragColor = vec4(1.0);
}

\simple2.fs

#version 330 core

uniform sampler2D u_texture;

in vec2 v_uv;
out vec4 FragColor;

void main()
{
	vec4 color = texture2D(u_texture, v_uv);
	FragColor = vec4(color.xyz, 1.0);
}

\flat.fs

#version 330 core

uniform vec4 u_color;

out vec4 FragColor;

void main()
{
	FragColor = u_color;
}


\texture.fs

#version 330 core

in vec3 v_position;
in vec3 v_world_position;
in vec3 v_normal;
in vec2 v_uv;
in vec4 v_color;

uniform vec3 u_camera_position;

uniform vec4 u_color;
uniform sampler2D u_texture;
uniform float u_time;
uniform float u_alpha_cutoff;

uniform vec3 u_ambient_light;
uniform vec3 u_light_color;
uniform vec3 u_light_vector;
uniform float u_light_type;

uniform vec3 u_light_position;
uniform float u_light_intensity;
uniform float u_light_maxdist;

uniform vec3 spotDirection;
uniform float spotCosineCutoff;
uniform float spotExponent;

uniform sampler2D shadowmap;
uniform sampler2DShadow gShadowMap;
uniform vec2 gMapSize;
uniform mat4 u_shadow_viewproj;
uniform float u_shadow_bias;

out vec4 FragColor;

#define EPSILON 0.00001


float CalcShadowFactor(vec4 LightSpacePos)
{
    vec3 ProjCoords = LightSpacePos.xyz / LightSpacePos.w;
    vec2 UVCoords;
    UVCoords.x = 0.5 * ProjCoords.x + 0.5;
    UVCoords.y = 0.5 * ProjCoords.y + 0.5;
    float zeta = 0.5 * ProjCoords.z + 0.5;

    float xOffset = 1.0/gMapSize.x;
    float yOffset = 1.0/gMapSize.y;
    float Factor = 0.0;

    for (int y = -1 ; y <= 1 ; y++) {
        for (int x = -1 ; x <= 1 ; x++) {
            vec2 Offsets = vec2(x * xOffset, y * yOffset);
            vec3 UVC = vec3(UVCoords + Offsets, zeta + EPSILON + 0.0001);
            Factor += texture(gShadowMap, UVC);
        }
    }
    return ((Factor / 18.0));
}
 

void main()
{
	vec2 uv = v_uv;
	vec4 color = u_color;
	color *= texture2D( u_texture, uv );
	if(color.a < u_alpha_cutoff)
		discard;
	
	vec3 light = vec3(0.0);
	light += u_ambient_light;
	vec3 N = normalize(v_normal);
	vec3 L = vec3(0.0);
	
	float att_factor = 1;
	float spotFactor = 1;
	//DIRECTIONAL
	if(u_light_type == 0.0)
	{
		L = u_light_vector*u_light_intensity;
		//L = normalize(L);
		float NdotL = max(dot(N,L),0.0);
		NdotL = clamp(NdotL, 0.0, 1.0);
		light += (NdotL * u_light_color);
		
	}
	//OMNI
	else if (u_light_type == 1.0)
	{
		L = u_light_position-v_world_position;
		float light_distance = length(L);
		L = normalize(L)*u_light_intensity;
		att_factor = u_light_maxdist - light_distance;
		att_factor /= u_light_maxdist;
		att_factor = max(att_factor, 0.0);
		float NdotL = max(dot(N,L),0.0);
		NdotL = clamp(NdotL, 0.0, 1.0);
		light += (NdotL * u_light_color)*att_factor*att_factor;
		
	}
	//SPOT
	else
	{
		L = v_world_position - u_light_position;
		L = normalize(L);
		float NdotL = max(dot(N,-L),0.0);
		NdotL = clamp(NdotL, 0.0, 1.0);
		float spotCosine = 1;
		if(spotCosineCutoff > 0.0){
			vec3 D = normalize(spotDirection);
			
			spotCosine = dot(D, L);
			if(spotCosine >= spotCosineCutoff){
				spotFactor = pow(spotCosine, spotExponent);
			}
			else{
				spotFactor = 0;
			}
		}
		light += (NdotL * u_light_color)*u_light_intensity*spotFactor;
		
	}
	vec4 proj_pos = u_shadow_viewproj * vec4(v_world_position,1.0);
	float shadow_factor = CalcShadowFactor(proj_pos);
	
	/*
	vec2 shadow_uv = proj_pos.xy / proj_pos.w;
	shadow_uv = shadow_uv * 0.5 + vec2(0.5);
	
	float real_depth = (proj_pos.z - u_shadow_bias) / proj_pos.w;
	real_depth = real_depth * 0.5 + 0.5;

	float shadow_depth = texture( shadowmap, shadow_uv).x;
	
	float shadow_factor = 1.0;
	if( shadow_depth < real_depth ){
		shadow_factor = 0.0; 
	}	
	if(	shadow_uv.x < 0.0 || shadow_uv.x > 1.0 || shadow_uv.y < 0.0 || shadow_uv.y > 1.0){
		shadow_factor = 1.0;
	}
	if(real_depth < 0.0 || real_depth > 1.0){
		shadow_factor = 1.0;
	}
	*/
	
	color.xyz *= light*shadow_factor;
	FragColor = color;
}


\multi.fs

#version 330 core

in vec3 v_position;
in vec3 v_world_position;
in vec3 v_normal;
in vec2 v_uv;

uniform vec4 u_color;
uniform sampler2D u_texture;
uniform sampler2D u_material_map;
uniform sampler2D u_emissive_texture;
uniform sampler2D u_normal_map;
uniform float hasNormalmap;
uniform vec3 u_camera_pos;
uniform vec3 u_emissive_factor;

uniform float u_time;
uniform float u_alpha_cutoff;
uniform float u_texture_rep;

uniform bool degamma;


// IRRADIANCE
uniform sampler2D u_probes_texture;
uniform vec3 u_irr_start;
uniform vec3 u_irr_end;
uniform vec3 u_irr_delta;
uniform vec3 u_irr_dims;
uniform float u_num_probes;
uniform float u_irr_normal_distance;
uniform bool SHinterp;
const float Pi = 3.141592654;
const float CosineA0 = Pi;
const float CosineA1 = (2.0 * Pi) / 3.0;
const float CosineA2 = Pi * 0.25;
struct SH9 { float c[9]; }; //to store weights
struct SH9Color { vec3 c[9]; }; //to store colors

layout(location = 0) out vec4 FragColor;
layout(location = 1) out vec4 NormalColor;
layout(location = 2) out vec4 Material_map;
layout(location = 3) out vec4 Irradiance_map;


mat3 cotangent_frame(vec3 N, vec3 p, vec2 uv)
{
	// get edge vectors of the pixel triangle
	vec3 dp1 = dFdx( p );
	vec3 dp2 = dFdy( p );
	vec2 duv1 = dFdx( uv );
	vec2 duv2 = dFdy( uv );
	
	// solve the linear system
	vec3 dp2perp = cross( dp2, N );
	vec3 dp1perp = cross( N, dp1 );
	vec3 T = dp2perp * duv1.x + dp1perp * duv2.x;
	vec3 B = dp2perp * duv1.y + dp1perp * duv2.y;
 
	// construct a scale-invariant frame 
	float invmax = inversesqrt( max( dot(T,T), dot(B,B) ) );
	return mat3( T * invmax, B * invmax, N );
}

vec3 perturbNormal(vec3 N, vec3 V, vec2 uv, vec3 normal_pixel)
{
	normal_pixel = normal_pixel * 255./127. - 128./127.;
	mat3 TBN = cotangent_frame(N, V, uv);
	return normalize(TBN * normal_pixel);
}


void SHCosineLobe(in vec3 dir, out SH9 sh) //SH9
{
	// Band 0
	sh.c[0] = 0.282095 * CosineA0;
	// Band 1
	sh.c[1] = 0.488603 * dir.y * CosineA1; 
	sh.c[2] = 0.488603 * dir.z * CosineA1;
	sh.c[3] = 0.488603 * dir.x * CosineA1;
	// Band 2
	sh.c[4] = 1.092548 * dir.x * dir.y * CosineA2;
	sh.c[5] = 1.092548 * dir.y * dir.z * CosineA2;
	sh.c[6] = 0.315392 * (3.0 * dir.z * dir.z - 1.0) * CosineA2;
	sh.c[7] = 1.092548 * dir.x * dir.z * CosineA2;
	sh.c[8] = 0.546274 * (dir.x * dir.x - dir.y * dir.y) * CosineA2;
}

vec3 ComputeSHIrradiance(in vec3 normal, in SH9Color sh)
{
	// Compute the cosine lobe in SH, oriented about the normal direction
	SH9 shCosine;
	SHCosineLobe(normal, shCosine);
	// Compute the SH dot product to get irradiance
	vec3 irradiance = vec3(0.0);
	for(int i = 0; i < 9; ++i)
		irradiance += sh.c[i] * shCosine.c[i];

	return irradiance;
}

int index3D(int x, int y, int z, vec3 dim){
	return int(dim.y*dim.z*x + dim.z*y + z);
}

vec3 computeIrradianceInterp(sampler2D probes_texture, vec3 irr_start, vec3 irr_end, vec3 irr_delta, vec3 irr_dims, float num_probes, float irr_normal_distance, vec3 worldpos, vec3 N){

	vec3 irradiance = vec3(0);
//computing nearest probe index based on world position
	vec3 irr_range = irr_end - irr_start;
	
	if(1){
	//if(worldpos.x > irr_start.x && worldpos.x < irr_end.x && worldpos.z > irr_start.z && worldpos.z < irr_end.z){
		vec3 irr_local_pos = clamp( worldpos - u_irr_start + N * 1.0, vec3(0.0), irr_range );

	
		//convert from world pos to grid pos
		vec3 irr_norm_pos = irr_local_pos / irr_delta;
	
		//round values as we cannot fetch between rows for now
		vec3 local_indices = floor( irr_norm_pos - vec3(0,0,0) );
		vec3 factors = irr_norm_pos - local_indices;

		vec3 irr[8];
		SH9Color sh;
		
		for (int x=0; x<=1; x++){
			for (int y=-0; y<=1; y++){
				for (int z=0; z<=1; z++){
					//compute in which row is the probe stored
					float row = (local_indices.x + x) + (local_indices.y + y)* irr_dims.x + (local_indices.z + z )* irr_dims.x * irr_dims.y;
		
					//find the UV.y coord of that row in the probes texture
					float row_uv = (row + 1.0) / (num_probes + 1.0);
		
					//fill the coefficients
					const float d_uvx = 1.0 / 9.0;
					for(int i = 0; i < 9; ++i)
					{
						vec2 coeffs_uv = vec2( (float(i)+0.5) * d_uvx, row_uv );
						sh.c[i] = texture( probes_texture, coeffs_uv).xyz;
					}
	
					//now we can use the coefficients to compute the irradiance
					int index = index3D(x,y,z,vec3(2));
					irr[index3D(x,y,z,vec3(2))] = ComputeSHIrradiance( N, sh );
				}
			}
		}
		
		vec3 irrTF = mix( irr[index3D(0,1,0,vec3(2))], irr[index3D(1,1,0,vec3(2))], factors.x );
		vec3 irrBF = mix( irr[index3D(0,0,0,vec3(2))], irr[index3D(1,0,0,vec3(2))], factors.x );
		vec3 irrTN = mix( irr[index3D(0,1,1,vec3(2))], irr[index3D(1,1,1,vec3(2))], factors.x );
		vec3 irrBN = mix( irr[index3D(0,0,1,vec3(2))], irr[index3D(1,0,1,vec3(2))], factors.x );

		vec3 irrT = mix( irrTF, irrTN, factors.z );
		vec3 irrB = mix( irrBF, irrBN, factors.z );

		return mix( irrB, irrT, factors.y );
		
		
	}
	
	
	return vec3(0,0,0);
	
} 

vec3 computeIrradiance(sampler2D probes_texture, vec3 irr_start, vec3 irr_end, vec3 irr_delta, vec3 irr_dims, float num_probes, float irr_normal_distance, vec3 worldpos, vec3 N){

	vec3 irradiance = vec3(0);
//computing nearest probe index based on world position
	vec3 irr_range = irr_end - irr_start;
	
	//if(worldpos.x > irr_start.x && worldpos.x < irr_end.x && worldpos.z > irr_start.z && worldpos.z < irr_end.z)
	if(1){
		vec3 irr_local_pos = clamp( worldpos - u_irr_start + normalize(N) * 8.0, vec3(0.0), irr_range );

	
		//convert from world pos to grid pos
		vec3 irr_norm_pos = irr_local_pos / irr_delta;
	
		//round values as we cannot fetch between rows for now
		vec3 local_indices = round( irr_norm_pos - vec3(0,0,0) );

		//compute in which row is the probe stored
		float row = local_indices.x + local_indices.y * irr_dims.x + local_indices.z * irr_dims.x * irr_dims.y;
	
		//find the UV.y coord of that row in the probes texture
		float row_uv = (row + 1.0) / (num_probes + 1.0);
	
	
		SH9Color sh;
	
		//fill the coefficients
		const float d_uvx = 1.0 / 9.0;
		for(int i = 0; i < 9; ++i)
		{
			vec2 coeffs_uv = vec2( (float(i)+0.5) * d_uvx, row_uv );
			sh.c[i] = texture( probes_texture, coeffs_uv).xyz;
		}
	
		//now we can use the coefficients to compute the irradiance
		irradiance = ComputeSHIrradiance( normalize(N), sh );
	}
	
	
	return irradiance;
	
} 

void main()
{
	vec2 uv = v_uv;
	vec4 color = u_color;
	color *= texture( u_texture, uv*u_texture_rep );
	vec4 material = texture(u_material_map, uv*u_texture_rep);
	float emissive = texture(u_emissive_texture, uv*u_texture_rep).x;
	emissive += u_emissive_factor.x;
	
	if(color.a < 0.9 && floor(mod( (gl_FragCoord.x +gl_FragCoord.y)*0.5 , 2.0)) == 0)
		discard;
	if(color.a < 0.9 && floor(mod( (gl_FragCoord.x -gl_FragCoord.y)*0.5 , 2.0)) == 0)
		discard;
	
	vec3 N;
	if(hasNormalmap == 1.0){
		vec4 normal_texture = texture(u_normal_map, uv*u_texture_rep );
		N = perturbNormal( normalize(v_normal), v_world_position, uv*u_texture_rep, normal_texture.xyz );
		N = normalize(N);
	}else{
		N = normalize(v_normal);
	}
	
	vec3 irr;
	if(SHinterp)
		irr = computeIrradianceInterp(u_probes_texture, u_irr_start, u_irr_end, u_irr_delta, u_irr_dims, u_num_probes, u_irr_normal_distance, v_world_position, N);
	else
		irr = computeIrradiance(u_probes_texture, u_irr_start, u_irr_end, u_irr_delta, u_irr_dims, u_num_probes, u_irr_normal_distance, v_world_position, N);
		
	FragColor = color;
	NormalColor = vec4(N * 0.5 + 0.5, 1.0);
	Material_map = vec4(emissive, material.z, material.y, 1.0);
	Irradiance_map = vec4(irr, 1.0);
	//texture2D(u_probes_texture, gl_FragCoord.xy / vec2(1024, 768)).xyz
}


\depth.fs

#version 330 core

uniform vec2 u_camera_nearfar;
uniform sampler2D u_texture; //depth map
in vec2 v_uv;
out vec4 FragColor;

void main()
{
	float n = u_camera_nearfar.x;
	float f = u_camera_nearfar.y;
	float z = texture2D(u_texture,v_uv).x;
	float color = n * (z + 1.0) / (f + n - z * (f - n));
	FragColor = vec4(color);
}

\forward.fs

#version 330 core

in vec3 v_position;
in vec3 v_world_position;
in vec3 v_normal;
in vec2 v_uv;
in vec4 v_color;

uniform sampler2D u_texture;
uniform sampler2D u_normal_texture;
uniform sampler2D u_rough_metal_texture;
uniform sampler2D u_emissive_texture;

uniform vec3 u_camera_pos;
uniform vec4 u_color;
uniform float u_alpha_cutoff;
uniform float u_texture_rep;
uniform float u_light_type;
uniform float u_light_maxdist;
uniform float u_light_intensity;
uniform float u_ambient_light;
uniform float u_emmisive_factor;


uniform mat4 u_inverse_viewprojection;
uniform vec3 u_light_position;
uniform vec3 u_light_color;
uniform vec3 u_light_vector;

uniform vec2 gMapSize;

uniform vec3 spotDirection;
uniform float spotCosineCutoff;
uniform float spotExponent;

uniform sampler2DShadow gShadowMap;
uniform sampler2D shadowmap;
uniform mat4 u_shadow_viewproj;
uniform float u_shadow_bias;

uniform bool degamma;
uniform bool pbr;

layout(location=0) out vec4 FragColor;

#define RECIPROCAL_PI 0.3183098861837697
#define PI 3.14159265358979323846264338327950288

float D_GGX (	const in float NoH, const in float linearRoughness ){
	float a2 = linearRoughness * linearRoughness;
	float f = (NoH * NoH) * (a2 - 1.0) + 1.0;
	return a2 / (PI * f * f);
}

vec3 F_Schlick( const in float VoH, const in vec3 f0){
	float f = pow(1.0 - VoH, 5.0);
	return f0 + (vec3(1.0) - f0) * f;
}

float GGX(float NdotV, float k){
	return NdotV / (NdotV * (1.0 - k) + k);
}
	
float G_Smith( float NdotV, float NdotL, float roughness)
{
	float k = pow(roughness + 1.0, 2.0) / 8.0;
	return GGX(NdotL, k) * GGX(NdotV, k);
}

vec3 specularBRDF( float roughness, vec3 f0, float NoH, float NoV, float NoL, float LoH ){
	float a = roughness * roughness;

	// Normal Distribution Function
	float D = D_GGX( NoH, a );

	// Fresnel Function
	vec3 F = F_Schlick( LoH, f0 );

	// Visibility Function (shadowing/masking)
	float G = G_Smith( NoV, NoL, roughness );
		
	// Norm factor
	vec3 spec = D * G * F;
	spec /= (4.0 * NoL * NoV + 1e-6);

	return spec;
}

// Diffuse Reflections: Disney BRDF using retro-reflections using F term, this is much more complex!!

/*float Fd_Burley ( const in float NoV, const in float NoL,const in float LoH, const in float linearRoughness){
        float f90 = 0.5 + 2.0 * linearRoughness * LoH * LoH;
        float lightScatter = F_Schlick(NoL, 1.0, f90);
        float viewScatter  = F_Schlick(NoV, 1.0, f90);
        return lightScatter * viewScatter * RECIPROCAL_PI;
}*/

vec3 PBR(vec3 color, vec3 N, float roughness, float metalness, vec3 worldpos, vec3 L){

	vec3 V = normalize(u_camera_pos - worldpos);
	vec3 H = normalize(V+L);
	vec3 R = reflect(L, N);
		
	float NoH = clamp(dot(N, H), 0.0, 1.0);
	float NdotL = max(dot(N,L),0.0);
	NdotL = clamp(NdotL, 0.0, 1.0);
	float NoV = clamp(dot(N,V), 0.0, 1.0);
	float NoL = clamp(dot(N,L), 0.0, 1.0);
	float LoH = clamp(dot(L,H), 0.0, 1.0);
		
		
	vec3 f0 = color.xyz * metalness + (vec3(0.5) * (1.0-metalness));

	//metallic materials do not have diffuse
	vec3 diffuseColor = (1.0 - metalness) * color.xyz;

	//compute the specular
	vec3 Fr_d = specularBRDF( roughness, f0, NoH, NoV, NoL, LoH);

	// Here we use the Burley, but you can replace it by the Lambert.
	//float linearRoughness = roughness*roughness;
	//vec3 Fd_d = diffuseColor * Fd_Burley(NoV,NoL,LoH,linearRoughness); 
	vec3 Fd_d = color.xyz / PI;
	//add diffuse and specular reflection
	return (Fr_d + Fd_d);
}

void main(){
	
	vec2 uv = v_uv*u_texture_rep;
	vec4 color = u_color;
	color *= texture2D( u_texture, uv );
	
	vec3 light = vec3(0.0);
	vec3 N = normalize(v_normal);
	
	float att_factor = 1;
	float spotFactor = 1;
		
	vec3 L = vec3(0.0);
	vec4 rough_metal = texture(u_rough_metal_texture, uv);
	float emmisive = texture(u_emissive_texture, uv).x;
		
	if(degamma == true){
		color.xyz = pow(color.xyz,vec3(2.2));	 
		rough_metal.xyz = pow(rough_metal.xyz,vec3(2.2)); 
	}
		
	float roughness = rough_metal.y;
	float metalness = rough_metal.z;
	
	vec3 lightpos = u_light_position;
	
	
	///////////////////////// SHADOW MAP

	vec4 proj_pos = u_shadow_viewproj * vec4(v_world_position,1.0);
	vec2 shadow_uv = proj_pos.xy / proj_pos.w;
	shadow_uv = shadow_uv * 0.5 + vec2(0.5);
	shadow_uv = vec2(clamp(shadow_uv.x, 0, 1),clamp(shadow_uv.y, 0, 1)); //if its out of [0,1], no shadow
	float real_depth = (proj_pos.z - u_shadow_bias) / proj_pos.w;
	real_depth = real_depth * 0.5 + 0.5;
	float shadow_factor = 1.0;
	
	//Control if the uv is out of shadow map
	if(shadow_uv.x > 0 && shadow_uv.x < 1 &&  shadow_uv.y > 0 && shadow_uv.y < 0.9 && real_depth > 0 && real_depth < 1){
		float shadow_depth = texture( shadowmap, shadow_uv).x;
		if( shadow_depth < real_depth ){
				shadow_factor = 0.0;
			}
		
	}else if(u_light_type == 0) {
		shadow_factor = 1.0;
	}else
		shadow_factor = 0.0;
	
	
	if(u_light_type == 0.0)	{ //DIRECTIONAL
		L = -u_light_vector;
		//L = normalize(L);
		float NdotL = max(dot(N,L),0.0);
		NdotL = clamp(NdotL, 0.0, 1.0);
		
		vec3 direct = PBR(color.xyz, N, roughness, metalness, v_world_position, L);		
		if(pbr==true){
			light += pow(u_light_color.xyz,vec3(2.2)) * direct * shadow_factor *u_light_intensity;
		}
		else{
			light += pow(u_light_color.xyz,vec3(2.2)) * NdotL * shadow_factor *u_light_intensity * color.xyz;
		}
	}
	else if(u_light_type==1.0){ //OMNI - POINT
		L = lightpos - v_world_position;
		float light_distance = length(L);
		L /= light_distance;
		
		att_factor = u_light_maxdist - light_distance;
		att_factor /= u_light_maxdist;
		att_factor = max(att_factor, 0.0);
		
		vec3 direct = PBR(color.xyz, N, roughness, metalness, v_world_position, L);
		
		float NdotL = max(dot(N,L), 0.0);
		NdotL = clamp(NdotL, 0.0, 1.0);
		
		if(pbr==true){
			light += direct*pow(u_light_color.xyz,vec3(2.2))*u_light_intensity*att_factor*att_factor ;
		}
		else{
			light += NdotL*pow(u_light_color.xyz,vec3(2.2))*u_light_intensity*att_factor*att_factor ;
		}
		
	}
	else if(u_light_type==2.0){ //SPOT 
		L = v_world_position - lightpos;
		L = normalize(L);
		float NdotL = max(dot(N,-L),0.0);
		NdotL = clamp(NdotL, 0.0, 1.0);
		vec3 direct = PBR(color.xyz, N, roughness, metalness, v_world_position, -L);		
		
		//////////////////// SPOT FACTOR CALCULATION
		float spotCosine = 1;
		if(spotCosineCutoff > 0.0){
			vec3 D = normalize(spotDirection);
			
			spotCosine = dot(D, L);
			if(spotCosine >= spotCosineCutoff){
				spotFactor = pow(spotCosine, spotExponent);
			}
			else{
				spotFactor = 0;
			}
		}
		///////////////////
		if(pbr==true){
			light += direct * pow(u_light_color.xyz,vec3(2.2)) * u_light_intensity * spotFactor * shadow_factor;
		}
		else{
			light += NdotL * pow(u_light_color.xyz,vec3(2.2)) * u_light_intensity * spotFactor * shadow_factor;
		}
		
		//light += (NdotL*pow(u_light_color.xyz,vec3(2.2))*u_light_intensity) *spotFactor;
	
	}
	
	color *= vec4(light + u_ambient_light + emmisive + color.xyz*u_emmisive_factor,1.0);
	if(degamma == true){	
		color.xyz = pow(color.xyz,vec3(1.0/2.2)); 				//Degamma
		rough_metal.xyz = pow(rough_metal.xyz,vec3(1.0/2.2));
		
	}
	FragColor = vec4(color.xyz, 1.0);
	
}


\deferred.fs

#version 330 core
precision highp float;

in vec2 v_uv;
uniform sampler2D u_color_texture;
uniform sampler2D u_normal_texture;
uniform sampler2D u_extra_texture;
uniform sampler2D u_depth_texture;
uniform sampler2D u_ambient_texture;
uniform sampler2D u_irradiance_texture;

//IRRADIANCE	
uniform vec3 u_irr_start;
uniform vec3 u_irr_end;
uniform float u_irr_normal_distance;
uniform vec3 u_irr_delta;
uniform vec3 u_irr_dims;
uniform int u_num_probes;

uniform vec3 u_camera_pos;
uniform float u_light_type;
uniform float u_light_maxdist;
uniform float u_light_intensity;
uniform float u_ambient_light;

uniform mat4 u_inverse_viewprojection;
uniform vec3 u_light_position;
uniform vec3 u_light_color;
uniform vec3 u_light_vector;
uniform vec3 spotDirection;
uniform float spotCosineCutoff;
uniform float spotExponent;

uniform vec2 gMapSize;
uniform vec2 u_iRes;
uniform sampler2D shadow_map;
uniform sampler2DShadow gShadowMap;
uniform mat4 u_shadow_viewproj;
uniform float u_shadow_bias;

uniform bool degamma;
uniform bool pbr;
uniform bool ssao;
uniform bool SHinterp;


layout (location = 0) out vec4 FragColor;
layout (location = 1) out vec4 BrightColor;

#define RECIPROCAL_PI 0.3183098861837697
#define PI 3.14159265358979323846264338327950288
#define EPSILON 0.0001



float CalcShadowFactor(vec4 LightSpacePos){
	vec3 ProjCoords = LightSpacePos.xyz / LightSpacePos.w;
    vec2 UVCoords;
    UVCoords.x = 0.5 * ProjCoords.x + 0.5;
    UVCoords.y = 0.5 * ProjCoords.y + 0.5;
    float zeta = 0.5 * ProjCoords.z + 0.5;

    float xOffset = 1.0/gMapSize.x;
    float yOffset = 1.0/gMapSize.y;
    float Factor = 0.0;

		for (int y = -1 ; y <= 1 ; y++) {
			for (int x = -1 ; x <= 1 ; x++) {
				vec2 Offsets = vec2(x * xOffset, y * yOffset);
				vec3 UVC = vec3(UVCoords + Offsets, zeta + 0.00001);
				Factor += texture(gShadowMap, UVC);
			}
		}
    return ((Factor / 18.0));
}

float D_GGX (	const in float NoH, const in float linearRoughness ){
	float a2 = linearRoughness * linearRoughness;
	float f = (NoH * NoH) * (a2 - 1.0) + 1.0;
	return a2 / (PI * f * f);
}

vec3 F_Schlick( const in float VoH, const in vec3 f0){
	float f = pow(1.0 - VoH, 5.0);
	return f0 + (vec3(1.0) - f0) * f;
}

float GGX(float NdotV, float k){
	return NdotV / (NdotV * (1.0 - k) + k);
}

float G_Smith( float NdotV, float NdotL, float roughness)
{
	float k = pow(roughness + 1.0, 2.0) / 8.0;
	return GGX(NdotL, k) * GGX(NdotV, k);
}
vec3 specularBRDF( float roughness, vec3 f0, float NoH, float NoV, float NoL, float LoH ){
	float a = roughness * roughness;

	// Normal Distribution Function
	float D = D_GGX( NoH, a );

	// Fresnel Function
	vec3 F = F_Schlick( LoH, f0 );

	// Visibility Function (shadowing/masking)
	float G = G_Smith( NoV, NoL, roughness );
	
	vec3 spec = D * G * F;
	spec /= (4.0 * NoL * NoV + 1e-6);

	return spec;
}

vec3 PBR(vec3 color, vec3 N, float roughness, float metalness, vec3 worldpos, vec3 L){

	vec3 V = normalize(u_camera_pos - worldpos);
	vec3 H = normalize(V+L);
	vec3 R = reflect(L, N);
		
	float NoH = clamp(dot(N, H), 0.0, 1.0);
	float NdotL = max(dot(N,L),0.0);
	NdotL = clamp(NdotL, 0.0, 1.0);
	float NoV = clamp(dot(N,V), 0.0, 1.0);
	float NoL = clamp(dot(N,L), 0.0, 1.0);
	float LoH = clamp(dot(L,H), 0.0, 1.0);

	vec3 f0 = color.xyz * metalness + (vec3(0.5) * (1.0-metalness));

	//metallic materials do not have diffuse
	vec3 diffuseColor = (1.0 - metalness) * color.xyz;

	//compute the specular
	vec3 Fr_d = specularBRDF( roughness, f0, NoH, NoV, NoL, LoH);

	// Here we use the Burley, but you can replace it by the Lambert.
	//float linearRoughness = roughness*roughness;
	//vec3 Fd_d = diffuseColor * Fd_Burley(NoV,NoL,LoH,linearRoughness); 
	vec3 Fd_d = color.xyz / PI;
	return (Fr_d + Fd_d);
}


void main(){
	vec2 uv = gl_FragCoord.xy * u_iRes.xy;
	float att_factor = 1;
	float spotFactor = 1;
	float shadow_factor = 1.0;
	vec3 light = vec3(0.0);
	vec3 L = vec3(0.0);
	vec4 color = texture(u_color_texture, uv);
	vec4 color2;
	vec4 extra_texture = texture(u_extra_texture, uv);
	float ambient = texture(u_ambient_texture, uv).x;
	ambient = pow(ambient, 3.0);
	
	vec4 irradiance = texture(u_irradiance_texture, uv);
	
	if(degamma == true){
		color.xyz = pow(color.xyz,vec3(2.2));	 
		extra_texture.xyz = pow(extra_texture.xyz,vec3(2.2)); 
	}
	color2 = color;
	
	float depth = texture(u_depth_texture, uv).x;
	if (depth == 1.0)
		discard;
		
	vec4 normal_texture = texture(u_normal_texture, uv);
	vec3 N =  normal_texture.xyz *2.0 - 1.0;
	N = normalize(N);
	
	float emmisive;
	if(u_ambient_light != 0.0)
		 emmisive = extra_texture.x;
	else
		 emmisive = 0.0;
		 
	float roughness = extra_texture.y;
	float metalness = extra_texture.z;
	
	vec4 screenpos = vec4(uv.x*2.0 - 1.0, uv.y*2.0 - 1.0, depth*2.0 - 1.0, 1.0);
	vec4 proj_worldpos = u_inverse_viewprojection * screenpos;
	vec3 worldpos = proj_worldpos.xyz / proj_worldpos.w;
	
	vec3 lightpos = u_light_position;

	///////////////////////// SHADOW MAP
	
	/*
	vec4 proj_pos = u_shadow_viewproj * vec4(worldpos,1.0);
	if(u_light_type!=1.0){
		shadow_factor = CalcShadowFactor(proj_pos);
	}
	*/
	
	vec4 proj_pos = u_shadow_viewproj * vec4(worldpos,1.0);
	vec2 shadow_uv = proj_pos.xy / proj_pos.w;
	shadow_uv = shadow_uv * 0.5 + vec2(0.5);
	shadow_uv = vec2(clamp(shadow_uv.x, 0, 1),clamp(shadow_uv.y, 0, 1)); //if its out of [0,1], no shadow
	float real_depth = (proj_pos.z - 0.01) / proj_pos.w;
	real_depth = real_depth * 0.5 + 0.5;
	//float shadow_factor = 1.0;
	
	//Control if the uv is out of shadow map
	if(shadow_uv.x > 0 && shadow_uv.x < 1 &&  shadow_uv.y > 0 && shadow_uv.y < 1 && real_depth > 0 && real_depth < 1){
		float shadow_depth = texture( shadow_map, shadow_uv).x;
		if( shadow_depth < real_depth ){
				shadow_factor = 0.0;
			}
		
	}else if(u_light_type == 0) {
		shadow_factor = 1.0;
	}else
		shadow_factor = 0.0;
	
	
	if(u_light_type == 0.0)	{ //DIRECTIONAL
		L = -u_light_vector;
		//L = normalize(L);
		float NdotL = max(dot(N,L),0.0);
		NdotL = clamp(NdotL, 0.0, 1.0);
		
		vec3 direct = PBR(color.xyz, N, roughness, metalness, worldpos, L);		
		if(pbr==true){
			//light += pow(u_light_color.xyz,vec3(2.2)) * direct * shadow_factor *u_light_intensity;
			light += direct * shadow_factor *u_light_intensity;
		}
		else{
			light += pow(u_light_color.xyz,vec3(2.2)) * NdotL * shadow_factor *u_light_intensity;
		}
	}
	else if(u_light_type==1.0){ //OMNI - POINT
		L = lightpos - worldpos;
		float light_distance = length(L);
		L /= light_distance;
		
		att_factor = u_light_maxdist - light_distance;
		att_factor /= u_light_maxdist;
		att_factor = max(att_factor, 0.0);
		
		vec3 direct = PBR(color.xyz, N, roughness, metalness, worldpos, L);
		
		float NdotL = max(dot(N,L), 0.0);
		NdotL = clamp(NdotL, 0.0, 1.0);
		
		if(pbr==true){
			light += direct*pow(u_light_color.xyz,vec3(2.2))*u_light_intensity*att_factor*att_factor ;
		}
		else{
			light += NdotL*pow(u_light_color.xyz,vec3(2.2))*u_light_intensity*att_factor*att_factor ;
		}
		
	}
	else if(u_light_type==2.0){ //SPOT 
		L = worldpos - lightpos;
		float light_distance = length(L);
		att_factor = u_light_maxdist - light_distance;
		att_factor /= u_light_maxdist;
		att_factor = max(att_factor, 0.0);
		L = normalize(L);
		float NdotL = max(dot(N,-L),0.0);
		NdotL = clamp(NdotL, 0.0, 1.0);
		vec3 direct = PBR(color.xyz, N, roughness, metalness, worldpos, -L);		
		
		//////////////////// SPOT FACTOR CALCULATION
		float spotCosine = 1;
		if(spotCosineCutoff > 0.0){
			vec3 D = normalize(spotDirection);
			
			spotCosine = dot(D, L);
			if(spotCosine >= spotCosineCutoff){
				spotFactor = pow(spotCosine, spotExponent);
			}
			else{
				spotFactor = 0;
			}
		}
		///////////////////
		if(pbr==true){
			light += direct * pow(u_light_color.xyz,vec3(2.2)) * u_light_intensity * spotFactor * shadow_factor * att_factor;
		}
		else{
			light += NdotL * pow(u_light_color.xyz,vec3(2.2)) * u_light_intensity * spotFactor * shadow_factor * att_factor;
		}
		
		//light += (NdotL*pow(u_light_color.xyz,vec3(2.2))*u_light_intensity) *spotFactor;
	
	}
	
	irradiance.xyz = clamp(irradiance.xyz, 0.0,1.0);
	
	if(ssao){
		color *= vec4(light +  emmisive + u_ambient_light*ambient + irradiance.xyz,1.0);
	}
	else {
		color *= vec4(light + emmisive + u_ambient_light + irradiance.xyz,1.0);
	}
	//color *= vec4(irr, 1.0);
	if(degamma == true){	
		color.xyz = pow(color.xyz,vec3(1.0/2.2)); 				//Degamma
		extra_texture.xyz = pow(extra_texture.xyz,vec3(1.0/2.2));
		
	}
	FragColor = vec4(color.xyz, 1.0);
	BrightColor = color2*vec4(emmisive);
}


\ssao.fs

#version 330 core

in vec2 v_uv;
uniform sampler2D u_normal_texture;
uniform sampler2D u_depth_texture;

uniform vec3 u_camera_pos;
uniform mat4 u_inverse_viewprojection;
uniform mat4 u_viewprojection;

uniform vec2 u_iRes;

uniform vec3 u_points[64];

out vec4 FragColor;

mat3 cotangent_frame(vec3 N, vec3 p, vec2 uv)
{
	// get edge vectors of the pixel triangle
	vec3 dp1 = dFdx( p );
	vec3 dp2 = dFdy( p );
	vec2 duv1 = dFdx( uv );
	vec2 duv2 = dFdy( uv );
	
	// solve the linear system
	vec3 dp2perp = cross( dp2, N );
	vec3 dp1perp = cross( N, dp1 );
	vec3 T = dp2perp * duv1.x + dp1perp * duv2.x;
	vec3 B = dp2perp * duv1.y + dp1perp * duv2.y;
 
	// construct a scale-invariant frame 
	float invmax = inversesqrt( max( dot(T,T), dot(B,B) ) );
	return mat3( T * invmax, B * invmax, N );
}


void main()
{
	vec2 uv = v_uv.xy + u_iRes.xy*0.5;
	float ao = 0.0;
	float depth = texture(u_depth_texture, uv).x;
	if(depth >= 1.0){
		FragColor= vec4(1.0);
		return;
	}
	vec4 normal_texture = texture(u_normal_texture, uv);
	vec3 N =  normal_texture.xyz *2.0 - 1.0;
	N = normalize(N);
	
	vec4 screenpos = vec4(uv.x*2.0 - 1.0, uv.y*2.0 - 1.0, depth*2.0 - 1.0, 1.0);
	vec4 proj_worldpos = u_inverse_viewprojection * screenpos;
	vec3 worldpos = proj_worldpos.xyz / proj_worldpos.w;
	
	mat3 rotmat = cotangent_frame( N, worldpos, uv );
	
	int initialnumpixels = 64;
	int numpixels = initialnumpixels;
	for (int i=0; i<64; i++){
		vec3 rotated_point = rotmat * u_points[i];
		vec3 pos = worldpos + rotated_point*10.0;
		
		vec4 proj = u_viewprojection * vec4(pos, 1.0);
		proj.xy /= proj.w;			//clip space
		proj.z = (proj.z - 0.005) / proj.w;			//clip space
		proj.xyz = proj.xyz *0.5 + vec3(0.5); // screen coords
		
		float pixeldepth = texture(u_depth_texture, proj.xy).x;
		if(pixeldepth < proj.z)
			numpixels--;
	}
	ao = float(numpixels)/initialnumpixels;
		 
	FragColor = vec4(ao);

}

\instanced.vs

#version 330 core

in vec3 a_vertex;
in vec3 a_normal;
in vec2 a_uv;

in mat4 u_model;

uniform vec3 u_camera_pos;

uniform mat4 u_viewprojection;

//this will store the color for the pixel shader
out vec3 v_position;
out vec3 v_world_position;
out vec3 v_normal;
out vec2 v_uv;

void main()
{	
	//calcule the normal in camera space (the NormalMatrix is like ViewMatrix but without traslation)
	v_normal = (u_model * vec4( a_normal, 0.0) ).xyz;
	
	//calcule the vertex in object space
	v_position = a_vertex;
	v_world_position = (u_model * vec4( a_vertex, 1.0) ).xyz;
	
	//store the texture coordinates
	v_uv = a_uv;

	//calcule the position of the vertex using the matrices
	gl_Position = u_viewprojection * vec4( v_world_position, 1.0 );
}

\probe.fs

#version 330 core

in vec2 v_uv;
in vec3 v_normal;
in vec3 v_position;
in vec3 v_world_position;
uniform vec2 u_iRes;
uniform vec3 u_camera_pos;
uniform mat4 u_viewprojection;
uniform mat4 u_model;
uniform sampler2D u_depth_texture;

uniform vec3 u_coeffs[9];

out vec4 FragColor;


const float Pi = 3.141592654;
const float CosineA0 = Pi;
const float CosineA1 = (2.0 * Pi) / 3.0;
const float CosineA2 = Pi * 0.25;
struct SH9 { float c[9]; }; //to store weights
struct SH9Color { vec3 c[9]; }; //to store colors

void SHCosineLobe(in vec3 dir, out SH9 sh) //SH9
{
	// Band 0
	sh.c[0] = 0.282095 * CosineA0;
	// Band 1
	sh.c[1] = 0.488603 * dir.y * CosineA1; 
	sh.c[2] = 0.488603 * dir.z * CosineA1;
	sh.c[3] = 0.488603 * dir.x * CosineA1;
	// Band 2
	sh.c[4] = 1.092548 * dir.x * dir.y * CosineA2;
	sh.c[5] = 1.092548 * dir.y * dir.z * CosineA2;
	sh.c[6] = 0.315392 * (3.0 * dir.z * dir.z - 1.0) * CosineA2;
	sh.c[7] = 1.092548 * dir.x * dir.z * CosineA2;
	sh.c[8] = 0.546274 * (dir.x * dir.x - dir.y * dir.y) * CosineA2;
}

vec3 ComputeSHIrradiance(in vec3 normal, in SH9Color sh)
{
	// Compute the cosine lobe in SH, oriented about the normal direction
	SH9 shCosine;
	SHCosineLobe(normal, shCosine);
	// Compute the SH dot product to get irradiance
	vec3 irradiance = vec3(0.0);
	for(int i = 0; i < 9; ++i)
		irradiance += sh.c[i] * shCosine.c[i];

	return irradiance;
}


void main(){
	vec2 uv = gl_FragCoord.xy * u_iRes;
	float depth = texture(u_depth_texture, uv).x;
	if (depth < gl_FragCoord.z )
		discard;
		
	SH9Color color;
	color.c = u_coeffs;
	vec3 irr = ComputeSHIrradiance(v_normal, color);
	FragColor = vec4(irr,1.0);
}

\reflectionprobe.fs

#version 330 core

in vec2 v_uv;
in vec3 v_normal;
uniform vec2 u_iRes;
uniform vec3 u_camera_pos;
uniform mat4 u_viewprojection;
uniform mat4 u_inverse_viewprojection;

uniform sampler2D u_color_texture;
uniform sampler2D u_normal_texture;
uniform sampler2D u_depth_texture;
uniform sampler2D u_extra_texture;
uniform mat4 u_model;

uniform samplerCube u_environment_texture;

out vec4 FragColor;

void main(){
	vec2 uv = gl_FragCoord.xy * u_iRes;
	
	float depth = texture(u_depth_texture, uv).x;
	if (depth < gl_FragCoord.z )
		discard;
	vec4 color = texture(u_color_texture, uv);
	vec4 normal = texture(u_normal_texture, uv);
	vec3 N = normalize(normal.xyz*2.0-1.0);
	vec4 extra_texture = texture(u_extra_texture, uv);
	
	
	vec4 screenpos = vec4(v_uv.x*2.0 - 1.0, v_uv.y*2.0 - 1.0, depth*2.0 - 1.0, 1.0);
	vec4 proj_worldpos = u_inverse_viewprojection * screenpos;
	vec3 worldpos = proj_worldpos.xyz / proj_worldpos.w;
	
	vec3 basecolor = color.xyz;
	float roughness = extra_texture.y;
	float metalness = extra_texture.z;
	
	vec3 V = normalize(u_camera_pos - worldpos);
	vec3 R = reflect(V, v_normal);
	
	vec3 reflection = textureLod(u_environment_texture, -R, roughness*5.0).xyz;
	//reflection *= metalness;
	FragColor = vec4(reflection, 1.0);
}

\reflection.fs

#version 330 core

in vec2 v_uv;

uniform vec2 u_iRes;
uniform vec3 u_camera_pos;
uniform mat4 u_viewprojection;
uniform mat4 u_inverse_viewprojection;

uniform sampler2D u_color_texture;
uniform sampler2D u_normal_texture;
uniform sampler2D u_depth_texture;
uniform sampler2D u_extra_texture;

uniform samplerCube u_environment_texture;

out vec4 FragColor;

void main(){
	vec2 uv = gl_FragCoord.xy * u_iRes;
	
	vec4 color = texture(u_color_texture, uv);
	vec4 normal = texture(u_normal_texture, uv);
	vec3 N = normalize(normal.xyz*2.0-1.0);
	vec4 extra_texture = texture(u_extra_texture, uv);
	
	float depth = texture(u_depth_texture, uv).x;
	if(depth== 1.0)
		discard;

	vec4 screenpos = vec4(uv.x*2.0 - 1.0, uv.y*2.0 - 1.0, depth*2.0 - 1.0, 1.0);
	vec4 proj_worldpos = u_inverse_viewprojection * screenpos;
	vec3 worldpos = proj_worldpos.xyz / proj_worldpos.w;
	
	vec3 basecolor = color.xyz;
	float roughness = extra_texture.y;
	float metalness = extra_texture.z;
	
	vec3 V = normalize(u_camera_pos - worldpos);
	vec3 R = reflect(V, N);
	
	vec3 reflection = basecolor*textureLod(u_environment_texture, R, roughness*5.0).xyz;
	
	FragColor = vec4(reflection, roughness);
}


\volumetric.fs

#version 330 core

in vec2 v_uv;

uniform vec2 u_iRes;
uniform vec3 u_camera_pos;
uniform mat4 u_inverse_viewprojection;
uniform sampler2D u_depth_texture;
uniform vec3 u_light_color;
uniform vec3 u_light_vector;

uniform sampler2D shadow_map;
uniform mat4 u_shadow_viewproj;
uniform float u_shadow_bias;

uniform sampler2D u_noise_texture;
uniform vec3 u_random_vector;

out vec4 FragColor;

void main(){
	vec2 uv = gl_FragCoord.xy * u_iRes;
	
	float depth = texture(u_depth_texture, uv).x;
	
	vec4 screenpos = vec4(uv.x*2.0 - 1.0, uv.y*2.0 - 1.0, depth*2.0 - 1.0, 1.0);
	vec4 proj_worldpos = u_inverse_viewprojection * screenpos;
	vec3 worldpos = proj_worldpos.xyz / proj_worldpos.w;
	
	float noise = texture(u_noise_texture, uv+u_random_vector.xy).x;
	vec3 raydir = (worldpos-u_camera_pos);
		
	const int SAMPLES = 64;
	raydir /= float(SAMPLES);
	
	vec3 currentPos = u_camera_pos + raydir * noise;
	
	vec3 color = vec3(0.0);
	float density = 0.0;
	
	for(int i =0; i<SAMPLES; i++){
		float shadow_factor = 1.0;
		
		//comprovar les sombres
		vec4 proj_pos = u_shadow_viewproj * vec4(currentPos,1.0);
		vec2 shadow_uv = proj_pos.xy / proj_pos.w;
		shadow_uv = shadow_uv * 0.5 + vec2(0.5);
		//shadow_uv = vec2(clamp(shadow_uv.x, 0, 1),clamp(shadow_uv.y, 0, 1)); //if its out of [0,1], no shadow
		float real_depth = (proj_pos.z - u_shadow_bias) / proj_pos.w;
		real_depth = real_depth * 0.5 + 0.5;
		
		
		if(shadow_uv.x > 0 && shadow_uv.x < 1 &&  shadow_uv.y > 0 && shadow_uv.y < 0.9 && real_depth > 0 && real_depth < 1){
			float shadow_depth = texture( shadow_map, shadow_uv).x;
			if( shadow_depth < real_depth ){
					shadow_factor = 0.0;
				}
		}else {
			shadow_factor = 1.0;
		}
		
		density += 0.01*shadow_factor;
		
		color += shadow_factor * u_light_color;
		currentPos += raydir;
	}

	FragColor = vec4(color, density);
}

\skybox.fs

#version 330 core
in vec3 v_world_position;

uniform samplerCube u_texture;
uniform vec3 u_camera_pos;

out vec4 FragColor;

void main()
{
	vec3 V = normalize( u_camera_pos - v_world_position );
	FragColor = texture( u_texture, V );
}

\decals.fs

#version 330 core

in vec3 v_world_position;

uniform vec2 u_iRes;
uniform mat4 u_inverse_viewprojection;
uniform sampler2D u_texture;
uniform sampler2D u_depth_texture;

uniform vec3 u_camera_pos;
uniform mat4 u_invmodel;

out vec4 FragColor;

void main(){

	vec2 uv = gl_FragCoord.xy * u_iRes;
	
	float depth = texture(u_depth_texture, uv).x;
	if(depth == 1.0)
		discard;
	
	vec4 screenpos = vec4(uv.x*2.0 - 1.0, uv.y*2.0 - 1.0, depth*2.0 - 1.0, 1.0);
	vec4 proj_worldpos = u_inverse_viewprojection * screenpos;
	vec3 worldpos = proj_worldpos.xyz / proj_worldpos.w;

	vec3 decalpos = (u_invmodel * vec4(worldpos, 1.0)).xyz;
	vec2 uv_decal =  decalpos.xz* 0.5 + vec2(0.5);
	if(uv_decal.x <0.0 || uv_decal.x >1.0 || uv_decal.y <0.0 || uv_decal.y >1.0)
		discard;
	
	vec4 color = texture(u_texture, uv_decal);
	
	FragColor = color;
	//FragColor = vec4(1.0, 0.0, 0.0, 1.0);
}

\tonemapper.fs

#version 330 core

in vec2 v_uv;

uniform sampler2D u_color_texture;

uniform float u_scale;
uniform float u_average_lum;
uniform float u_lumwhite2;
uniform float u_igamma;

out vec4 FragColor;

vec3 RGB2xyY (vec3 rgb)
{
	const mat3 RGB2XYZ = mat3(0.4124, 0.3576, 0.1805, 0.2126, 0.7152, 0.0722, 0.0193, 0.1192, 0.9505);
	vec3 XYZ = RGB2XYZ * rgb;
	float f = (XYZ.x + XYZ.y + XYZ.z);

	return vec3(XYZ.x / f, 	XYZ.y / f, XYZ.y);
}


void main(){
	vec2 uv = v_uv;
	
	vec4 color= texture2D(u_color_texture, uv);
	
	vec3 rgb = color.xyz;
	float lum = dot(rgb, vec3(0.2126, 0.7152, 0.0722));
	float L = (u_scale / u_average_lum) * lum;
	float Ld = (L * (1.0 + L / u_lumwhite2)) / (1.0 + L);

	rgb = (rgb / lum) * Ld;
	rgb = max(rgb,vec3(0.001));
	rgb = pow( rgb, vec3( u_igamma ) );
	
	FragColor = vec4( rgb, color.a );

}


\bloom0.fs

#version 330 core

in vec2 v_uv;

uniform sampler2D u_color_texture;

uniform float horizontal;
uniform float weight[5] = float[] (0.227027, 0.1945946, 0.1216216, 0.054054, 0.016216);

layout (location = 0) out vec4 FragColor;

void main()
{             
    vec2 tex_offset = 1.0 / textureSize(u_color_texture, 0); // gets size of single texel
    vec3 result = texture(u_color_texture, v_uv).rgb * weight[0]; // current fragment's contribution
    vec3 color = vec3(0,0,0);
	vec3 color2 = vec3(0,0,0);
	
	if(horizontal == 1.0)
    {
        for(int i = 1; i < 5; ++i)
        {
            result += texture(u_color_texture, v_uv + vec2(tex_offset.x * i, 0.0)).rgb * weight[i];
            result += texture(u_color_texture, v_uv - vec2(tex_offset.x * i, 0.0)).rgb * weight[i];
        }
		color = vec3(result);
    }
    else
    {
        for(int i = 1; i < 5; ++i)
        {
            result += texture(u_color_texture, v_uv + vec2(0.0, tex_offset.y * i)).rgb * weight[i];
            result += texture(u_color_texture, v_uv - vec2(0.0, tex_offset.y * i)).rgb * weight[i];
        }
		
		color = vec3(result);
    }
	FragColor = vec4(color, 1.0);
}

\bloom.fs

#version 330 core

in vec2 v_uv;

uniform sampler2D u_color_texture;

uniform float horizontal;
uniform float weight[5] = float[] (0.227027, 0.1945946, 0.1216216, 0.054054, 0.016216);

layout (location = 0) out vec4 FragColor;

void main()
{             
    vec2 tex_offset = 1.0 / textureSize(u_color_texture, 0); // gets size of single texel
    vec3 result = texture(u_color_texture, v_uv).rgb * weight[0]; // current fragment's contribution
    vec3 color = vec3(0,0,0);
	vec3 color2 = vec3(0,0,0);
	

        for(int i = 1; i < 5; ++i)
        {
            result += texture(u_color_texture, v_uv + vec2(tex_offset.x * i, 0.0)).rgb * weight[i];
            result += texture(u_color_texture, v_uv - vec2(tex_offset.x * i, 0.0)).rgb * weight[i];
        }
		color = vec3(result);
    
	FragColor = vec4(color, 1.0);
}

\bloom2.fs

#version 330 core

in vec2 v_uv;

uniform sampler2D u_color_texture;

uniform float horizontal;
uniform float weight[5] = float[] (0.227027, 0.1945946, 0.1216216, 0.054054, 0.016216);

layout (location = 0) out vec4 FragColor;

void main()
{             
    vec2 tex_offset = 1.0 / textureSize(u_color_texture, 0); // gets size of single texel
    vec3 result = texture(u_color_texture, v_uv).rgb * weight[0]; // current fragment's contribution
    vec3 color = vec3(0,0,0);
	vec3 color2 = vec3(0,0,0);
	

        for(int i = 1; i < 5; ++i)
        {
            result += texture(u_color_texture, v_uv + vec2(0.0, tex_offset.y * i)).rgb * weight[i];
            result += texture(u_color_texture, v_uv - vec2(0.0, tex_offset.y * i)).rgb * weight[i];
        }
		
		color = vec3(result);

	FragColor = vec4(color, 1.0);
}

